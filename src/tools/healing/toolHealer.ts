/*---------------------------------------------------------------------------------------------
 * Tool Healing System - Auto-correction for LLM-generated parameters
 * Inspired by Gemini CLI healing patterns (Apache 2.0 License)
 * 
 * Purpose: Fix common issues in tool parameters generated by different LLM models
 * - Over-escaping (especially Gemini)
 * - Whitespace inconsistencies 
 * - Match precision problems
 * - Format inconsistencies
 *--------------------------------------------------------------------------------------------*/

import { LLMService, MetacognitionRequest, MetacognitionResponse } from './llmService';
import { ToolParameters, NoMatchError } from '../types/cliTypes';

export interface ToolHealingOptions {
    enableHealing?: boolean;
    enableMetacognition?: boolean;
    maxAttempts?: number;
    timeout?: number;
    enableCaching?: boolean;
    metacognitionModel?: string;
    openRouterApiKey?: string;
    siteUrl?: string;
    siteName?: string;
}

export interface HealingResult {
    success: boolean;
    originalParameters: ToolParameters;
    healedParameters?: ToolParameters;
    healingMethod?: 'unescape' | 'llm_correction' | 'newstring_adjustment' | 'pattern_matching';
    confidence?: number;
    metacognitionUsed: boolean;
    newError?: NoMatchError;
    error?: string;
}

export interface ModelBugPattern {
    name: string;
    pattern: RegExp;
    fix: (match: string, ...groups: any[]) => string;
    confidence: number;
}

export interface HealingMetrics {
    totalAttempts: number;
    successfulHealings: number;
    failedHealings: number;
    averageHealingTime: number;
    metacognitionUsageRate: number;
    healingsByModel: Record<string, {
        attempts: number;
        successes: number;
        totalTime: number;
        patterns?: Record<string, number>;
    }>;
    healingMethodStats: Record<string, {
        uses: number;
        successes: number;
        avgTime: number;
    }>;
    cacheHitRate: number;
}

/**
 * Tool Healing System - Metacognition for tool parameter correction
 * 
 * This system implements a 4-phase healing approach:
 * 1. Error Detection - Catch NoMatchError from failed tool execution
 * 2. Unescape Attempt - Fix common over-escaping issues
 * 3. LLM Correction - Use GPT-4o-mini for intelligent healing
 * 4. NewString Adjustment - Maintain consistency between old/new strings
 */
export class ToolHealer {
    private options: ToolHealingOptions & {
        enableHealing: boolean;
        enableMetacognition: boolean;
        maxAttempts: number;
        timeout: number;
        enableCaching: boolean;
        metacognitionModel: string;
    };
    private llmService: LLMService;
    private bugPatterns: Map<string, ModelBugPattern[]>;
    private healingCache: Map<string, ToolParameters>;
    private metrics: HealingMetrics;
    private logger?: (level: string, message: string, data?: any) => void;

    constructor(options: ToolHealingOptions = {}) {
        this.options = {
            enableHealing: true,
            enableMetacognition: true,
            maxAttempts: 3,
            timeout: 30000,
            enableCaching: true,
            metacognitionModel: 'gpt-4o-mini',
            ...options
        };

        // Initialize LLM service with API configuration
        const apiConfig = {
            openRouterApiKey: options.openRouterApiKey,
            siteUrl: options.siteUrl,
            siteName: options.siteName,
            defaultModel: options.metacognitionModel || 'gpt-4o-mini'
        };
        
        this.llmService = new LLMService(apiConfig);
        this.healingCache = new Map();
        this.bugPatterns = new Map();
        this.metrics = {} as HealingMetrics;
        
        this.initializeBugPatterns();
        this.resetMetrics();
    }

    public setLogger(logger: (level: string, message: string, data?: any) => void): void {
        this.logger = logger;
        this.llmService.setLogger(logger);
    }

    /**
     * Main healing entry point - attempts to fix tool parameters
     */
    public async healToolParameters(
        sourceModel: string,
        fileContent: string,
        originalParams: ToolParameters,
        error: NoMatchError
    ): Promise<HealingResult> {
        
        if (!this.options.enableHealing) {
            return {
                success: false,
                originalParameters: originalParams,
                metacognitionUsed: false
            };
        }

        const startTime = performance.now();
        const modelKey = this.normalizeModelName(sourceModel);
        
        this.metrics.totalAttempts++;
        if (!this.metrics.healingsByModel[modelKey]) {
            this.metrics.healingsByModel[modelKey] = {
                attempts: 0,
                successes: 0,
                totalTime: 0,
                patterns: {}
            };
        }
        this.metrics.healingsByModel[modelKey].attempts++;

        this.logger?.('info', `Starting healing process for tool parameters`, {
            sourceModel,
            error: error.message,
            filePath: error.filePath
        });

        const attemptHistory: Array<{
            method: string;
            parameters: ToolParameters;
            success: boolean;
            error?: string;
        }> = [];

        try {
            // Check cache first
            const cacheKey = this.generateCacheKey(originalParams, error);
            if (this.options.enableCaching && this.healingCache.has(cacheKey)) {
                const cachedResult = this.healingCache.get(cacheKey)!;
                this.updateCacheStats(true);
                
                this.logger?.('debug', 'Using cached healing result');
                return {
                    success: true,
                    originalParameters: originalParams,
                    healedParameters: cachedResult,
                    healingMethod: 'pattern_matching',
                    confidence: 0.95,
                    metacognitionUsed: false
                };
            }
            this.updateCacheStats(false);

            // Phase 1: Unescape Attempt
            const unescapeResult = await this.attemptUnescapeHealing(
                fileContent, originalParams, sourceModel
            );
            attemptHistory.push({
                method: 'unescape',
                parameters: unescapeResult.healedParameters || originalParams,
                success: unescapeResult.success,
                error: unescapeResult.error
            });

            if (unescapeResult.success) {
                return this.completeHealing(unescapeResult, startTime, sourceModel, cacheKey);
            }

            // Phase 2: Pattern-based healing
            const patternResult = await this.attemptPatternHealing(
                fileContent, originalParams, sourceModel
            );
            attemptHistory.push({
                method: 'pattern_matching',
                parameters: patternResult.healedParameters || originalParams,
                success: patternResult.success,
                error: patternResult.error
            });

            if (patternResult.success) {
                return this.completeHealing(patternResult, startTime, sourceModel, cacheKey);
            }

            // Phase 3: LLM Metacognition (if enabled)
            if (this.options.enableMetacognition) {
                const metacognitionResult = await this.attemptMetacognitionHealing(
                    sourceModel, fileContent, originalParams, error, attemptHistory
                );
                attemptHistory.push({
                    method: 'llm_correction',
                    parameters: metacognitionResult.healedParameters || originalParams,
                    success: metacognitionResult.success,
                    error: metacognitionResult.error
                });

                if (metacognitionResult.success) {
                    return this.completeHealing(metacognitionResult, startTime, sourceModel, cacheKey);
                }
            }

            // Phase 4: NewString Adjustment
            const adjustmentResult = await this.attemptNewStringAdjustment(
                originalParams, error
            );
            if (adjustmentResult.success) {
                return this.completeHealing(adjustmentResult, startTime, sourceModel, cacheKey);
            }

            // All healing attempts failed
            const duration = performance.now() - startTime;
            this.metrics.failedHealings++;
            this.updateModelMetrics(sourceModel, false, duration);

            this.logger?.('warn', 'All healing attempts failed', {
                sourceModel,
                attempts: attemptHistory.length,
                duration: Math.round(duration)
            });

            return {
                success: false,
                originalParameters: originalParams,
                metacognitionUsed: this.options.enableMetacognition,
                error: 'All healing methods exhausted'
            };

        } catch (healingError) {
            const duration = performance.now() - startTime;
            const errorMessage = healingError instanceof Error ? healingError.message : String(healingError);
            
            this.metrics.failedHealings++;
            this.updateModelMetrics(sourceModel, false, duration);
            
            this.logger?.('error', 'Unexpected error during healing', {
                error: errorMessage,
                duration: Math.round(duration)
            });

            return {
                success: false,
                originalParameters: originalParams,
                metacognitionUsed: this.options.enableMetacognition,
                error: `Healing failed: ${errorMessage}`
            };
        }
    }

    /**
     * Phase 1: Unescape Healing - Fix over-escaping issues
     */
    private async attemptUnescapeHealing(
        fileContent: string,
        originalParams: ToolParameters,
        sourceModel: string
    ): Promise<HealingResult> {
        
        const modelBugPatterns = this.getModelBugPatterns(sourceModel);
        if (modelBugPatterns.length === 0) {
            return {
                success: false,
                originalParameters: originalParams,
                metacognitionUsed: false
            };
        }

        this.logger?.('debug', `Attempting unescape healing with ${modelBugPatterns.length} patterns`);

        for (const bugPattern of modelBugPatterns) {
            const unescapedParams = this.applyBugPattern(originalParams, bugPattern);
            
            if (this.paramsHaveChanged(originalParams, unescapedParams)) {
                // Test if the unescaped version would work
                if (await this.testParameterMatch(fileContent, unescapedParams)) {
                    this.logger?.('info', `Unescape healing successful using pattern: ${bugPattern.name}`);
                    
                    return {
                        success: true,
                        originalParameters: originalParams,
                        healedParameters: unescapedParams,
                        healingMethod: 'unescape',
                        confidence: bugPattern.confidence,
                        metacognitionUsed: false
                    };
                }
            }
        }

        return {
            success: false,
            originalParameters: originalParams,
            metacognitionUsed: false
        };
    }

    /**
     * Phase 2: Pattern-based healing using regex patterns
     */
    private async attemptPatternHealing(
        fileContent: string,
        originalParams: ToolParameters,
        sourceModel: string
    ): Promise<HealingResult> {
        
        this.logger?.('debug', 'Attempting pattern-based healing');

        // Try generic patterns that work across models
        const genericPatterns: ModelBugPattern[] = [
            {
                name: 'trim_whitespace',
                pattern: /^\s+|\s+$/g,
                fix: () => '',
                confidence: 0.7
            },
            {
                name: 'normalize_whitespace',
                pattern: /\s+/g,
                fix: () => ' ',
                confidence: 0.6
            },
            {
                name: 'remove_trailing_newlines',
                pattern: /\n+$/g,
                fix: () => '',
                confidence: 0.8
            }
        ];

        for (const pattern of genericPatterns) {
            const adjustedParams = this.applyBugPattern(originalParams, pattern);
            
            if (this.paramsHaveChanged(originalParams, adjustedParams)) {
                if (await this.testParameterMatch(fileContent, adjustedParams)) {
                    this.logger?.('info', `Pattern healing successful using: ${pattern.name}`);
                    
                    return {
                        success: true,
                        originalParameters: originalParams,
                        healedParameters: adjustedParams,
                        healingMethod: 'pattern_matching',
                        confidence: pattern.confidence,
                        metacognitionUsed: false
                    };
                }
            }
        }

        return {
            success: false,
            originalParameters: originalParams,
            metacognitionUsed: false
        };
    }

    /**
     * Phase 3: LLM-powered healing using metacognition
     */
    private async attemptMetacognitionHealing(
        sourceModel: string,
        fileContent: string,
        originalParams: ToolParameters,
        error: NoMatchError,
        attemptHistory: Array<{
            method: string;
            parameters: ToolParameters;
            success: boolean;
            error?: string;
        }>
    ): Promise<HealingResult> {
        
        this.logger?.('debug', 'Attempting LLM metacognition healing');

        try {
            const metacognitionRequest: MetacognitionRequest = {
                sourceModel,
                fileContent,
                originalParameters: originalParams,
                error,
                attemptHistory
            };

            const response = await this.llmService.performMetacognition(metacognitionRequest);

            if (response.success && response.correctedParameters) {
                // Test if the corrected parameters would work
                if (await this.testParameterMatch(fileContent, response.correctedParameters)) {
                    this.logger?.('info', 'LLM metacognition healing successful', {
                        confidence: response.confidence,
                        reasoning: response.reasoning
                    });

                    this.metrics.metacognitionUsageRate = 
                        (this.metrics.metacognitionUsageRate * (this.metrics.totalAttempts - 1) + 1) / 
                        this.metrics.totalAttempts;

                    return {
                        success: true,
                        originalParameters: originalParams,
                        healedParameters: response.correctedParameters,
                        healingMethod: 'llm_correction',
                        confidence: response.confidence,
                        metacognitionUsed: true
                    };
                }
            }

            return {
                success: false,
                originalParameters: originalParams,
                metacognitionUsed: true,
                error: response.error || 'LLM correction did not resolve the issue'
            };

        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger?.('error', 'Metacognition healing failed', { error: errorMessage });

            return {
                success: false,
                originalParameters: originalParams,
                metacognitionUsed: true,
                error: `Metacognition error: ${errorMessage}`
            };
        }
    }

    /**
     * Phase 4: NewString Adjustment - Maintain consistency between old/new strings
     */
    private async attemptNewStringAdjustment(
        originalParams: ToolParameters,
        error: NoMatchError
    ): Promise<HealingResult> {
        
        this.logger?.('debug', 'Attempting newString adjustment healing');

        // Simple heuristic adjustments
        if ('oldString' in originalParams && 'newString' in originalParams) {
            const adjustedParams = { ...originalParams };
            
            // If oldString seems to have extra whitespace, adjust newString similarly
            const oldTrimmed = originalParams.oldString.trim();
            if (oldTrimmed !== originalParams.oldString) {
                adjustedParams.oldString = oldTrimmed;
                adjustedParams.newString = originalParams.newString.trim();
                
                return {
                    success: true,
                    originalParameters: originalParams,
                    healedParameters: adjustedParams,
                    healingMethod: 'newstring_adjustment',
                    confidence: 0.6,
                    metacognitionUsed: false
                };
            }
        }

        return {
            success: false,
            originalParameters: originalParams,
            metacognitionUsed: false
        };
    }

    /**
     * Initialize bug patterns for different models
     */
    private initializeBugPatterns(): void {
        this.bugPatterns = new Map();

        // Gemini patterns - known for over-escaping
        this.bugPatterns.set('gemini', [
            {
                name: 'gemini_over_escape',
                pattern: /\\+(n|t|r|'|"|`|\\)/g,
                fix: (match, char) => {
                    switch (char) {
                        case 'n': return '\n';
                        case 't': return '\t';
                        case 'r': return '\r';
                        case "'": return "'";
                        case '"': return '"';
                        case '`': return '`';
                        case '\\': return '\\';
                        default: return char;
                    }
                },
                confidence: 0.9
            },
            {
                name: 'gemini_backtick_escape',
                pattern: /\\+`/g,
                fix: () => '`',
                confidence: 0.85
            }
        ]);

        // Claude patterns - whitespace issues
        this.bugPatterns.set('claude', [
            {
                name: 'claude_extra_spaces',
                pattern: /\s{2,}/g,
                fix: () => ' ',
                confidence: 0.8
            },
            {
                name: 'claude_mixed_tabs',
                pattern: /\t\s+|\s+\t/g,
                fix: () => '\t',
                confidence: 0.75
            }
        ]);

        // DeepSeek patterns - JSON escaping issues
        this.bugPatterns.set('deepseek', [
            {
                name: 'deepseek_json_escape',
                pattern: /\\"/g,
                fix: () => '"',
                confidence: 0.8
            },
            {
                name: 'deepseek_newline_escape',
                pattern: /\\n/g,
                fix: () => '\n',
                confidence: 0.85
            }
        ]);
    }

    /**
     * Get bug patterns for a specific model
     */
    public getModelBugPatterns(modelFamily: string): ModelBugPattern[] {
        const normalizedModel = this.normalizeModelName(modelFamily);
        return this.bugPatterns.get(normalizedModel) || [];
    }

    /**
     * Apply a bug pattern to parameters
     */
    private applyBugPattern(params: ToolParameters, pattern: ModelBugPattern): ToolParameters {
        const corrected = { ...params };
        
        for (const [key, value] of Object.entries(corrected)) {
            if (typeof value === 'string') {
                corrected[key] = value.replace(pattern.pattern, pattern.fix);
            }
        }
        
        return corrected;
    }

    /**
     * Test if parameters would match in content
     */
    private async testParameterMatch(fileContent: string, params: ToolParameters): Promise<boolean> {
        // Simple test - check if oldString exists exactly once in content
        if ('oldString' in params && typeof params.oldString === 'string') {
            const occurrences = (fileContent.match(new RegExp(params.oldString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
            return occurrences === 1;
        }
        
        return false;
    }

    /**
     * Check if parameters have changed
     */
    private paramsHaveChanged(original: ToolParameters, modified: ToolParameters): boolean {
        return JSON.stringify(original) !== JSON.stringify(modified);
    }

    /**
     * Complete healing process with success
     */
    private completeHealing(
        result: HealingResult, 
        startTime: number, 
        sourceModel: string, 
        cacheKey: string
    ): HealingResult {
        const duration = performance.now() - startTime;
        
        this.metrics.successfulHealings++;
        this.updateModelMetrics(sourceModel, true, duration);
        this.updateMethodMetrics(result.healingMethod!, true, duration);

        // Cache successful healing
        if (this.options.enableCaching && result.healedParameters) {
            this.healingCache.set(cacheKey, result.healedParameters);
            
            // Limit cache size
            if (this.healingCache.size > 1000) {
                const firstKey = this.healingCache.keys().next().value;
                this.healingCache.delete(firstKey);
            }
        }

        this.logger?.('info', 'Healing completed successfully', {
            method: result.healingMethod,
            confidence: result.confidence,
            duration: Math.round(duration)
        });

        return result;
    }

    /**
     * Normalize model name for consistent tracking
     */
    private normalizeModelName(modelName: string): string {
        const lower = modelName.toLowerCase();
        if (lower.includes('gemini')) return 'gemini';
        if (lower.includes('claude')) return 'claude';
        if (lower.includes('deepseek')) return 'deepseek';
        if (lower.includes('gpt')) return 'gpt';
        return 'unknown';
    }

    /**
     * Generate cache key for parameters
     */
    private generateCacheKey(params: ToolParameters, error: NoMatchError): string {
        const paramHash = JSON.stringify(params).slice(0, 100);
        const errorHash = error.message.slice(0, 50);
        return `${paramHash}:${errorHash}`;
    }

    /**
     * Update cache statistics
     */
    private updateCacheStats(hit: boolean): void {
        // Simple cache hit rate tracking
        const total = this.metrics.totalAttempts;
        const currentRate = this.metrics.cacheHitRate;
        this.metrics.cacheHitRate = ((currentRate * (total - 1)) + (hit ? 1 : 0)) / total;
    }

    /**
     * Update model-specific metrics
     */
    private updateModelMetrics(sourceModel: string, success: boolean, duration: number): void {
        const modelKey = this.normalizeModelName(sourceModel);
        const modelStats = this.metrics.healingsByModel[modelKey];
        
        if (modelStats) {
            if (success) {
                modelStats.successes++;
            }
            modelStats.totalTime += duration;
        }

        // Update average healing time
        const totalAttempts = this.metrics.successfulHealings + this.metrics.failedHealings;
        const currentAvg = this.metrics.averageHealingTime;
        this.metrics.averageHealingTime = ((currentAvg * (totalAttempts - 1)) + duration) / totalAttempts;
    }

    /**
     * Update healing method statistics
     */
    private updateMethodMetrics(method: string, success: boolean, duration: number): void {
        if (!this.metrics.healingMethodStats[method]) {
            this.metrics.healingMethodStats[method] = {
                uses: 0,
                successes: 0,
                avgTime: 0
            };
        }

        const methodStats = this.metrics.healingMethodStats[method];
        methodStats.uses++;
        if (success) {
            methodStats.successes++;
        }
        methodStats.avgTime = ((methodStats.avgTime * (methodStats.uses - 1)) + duration) / methodStats.uses;
    }

    /**
     * Reset metrics to initial state
     */
    private resetMetrics(): void {
        this.metrics = {
            totalAttempts: 0,
            successfulHealings: 0,
            failedHealings: 0,
            averageHealingTime: 0,
            metacognitionUsageRate: 0,
            healingsByModel: {},
            healingMethodStats: {},
            cacheHitRate: 0
        };
    }

    /**
     * Get current healing metrics
     */
    public getMetrics(): HealingMetrics {
        return { ...this.metrics };
    }

    /**
     * Get cache statistics
     */
    public getCacheStats() {
        return {
            size: this.healingCache.size,
            hitRate: this.metrics.cacheHitRate,
            hits: Math.round(this.metrics.totalAttempts * this.metrics.cacheHitRate),
            misses: Math.round(this.metrics.totalAttempts * (1 - this.metrics.cacheHitRate))
        };
    }

    /**
     * Clear healing cache
     */
    public clearCache(): void {
        this.healingCache.clear();
        this.metrics.cacheHitRate = 0;
    }
}

export default ToolHealer;